# -*- coding: utf-8 -*-
"""Minmax tiny_nerf_pytorch

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/176nZljfbtj3hWft2Z4ryEfnBwsTfhxzN

## Tiny NeRF (A PyTorch implementation)

So, this weekend, I was catching up on this _cool paper_ titled [*NeRF: Representing scenes as neural radiance fields for view synthesis*](https://arxiv.org/abs/2003.08934)!

The authors released a TensorFlow implementation [here](https://github.com/bmild/nerf). Deciding to delve deeper, I ported their code to PyTorch, cause why not!

> *DISCLAIMER*: This notebook (and repository) is work-in-progress. Although I have rigorously tested most modules in here (to faithfully replicate the original implementation), my implementation at places deviates from the authors'. Comments/criticism welcome!

> All functions that have a `#TESTED` under the docstring imply that they have been tested against their corresponding tensorflow impls.
"""

import os

gpu_n = '1'
os.environ['CUDA_VISIBLE_DEVICES'] = gpu_n  # args.gpu_no
if not os.path.exists('ToyResults'):
    os.makedirs('ToyResults')

# Import all the good stuff
from typing import Optional

import numpy as np
import torch
import matplotlib.pyplot as plt

from loss_functions import perceptual_loss, vgg

"""## A few utility functions

#### Bridging PyTorch and TensorFlow functionality

There's plenty of differences in function signatures (and in functionality) b/w PyTorch and TensorFlow. Here's a few modules that help bridge the gap (for this particular impl).
"""


def meshgrid_xy(tensor1: torch.Tensor, tensor2: torch.Tensor) -> (torch.Tensor, torch.Tensor):
    """Mimick np.meshgrid(..., indexing="xy") in pytorch. torch.meshgrid only allows "ij" indexing.
    (If you're unsure what this means, safely skip trying to understand this, and run a tiny example!)

    Args:
      tensor1 (torch.Tensor): Tensor whose elements define the first dimension of the returned meshgrid.
      tensor2 (torch.Tensor): Tensor whose elements define the second dimension of the returned meshgrid.
    """
    # TESTED
    ii, jj = torch.meshgrid(tensor1, tensor2)
    return ii.transpose(-1, -2), jj.transpose(-1, -2)


def cumprod_exclusive(tensor: torch.Tensor) -> torch.Tensor:
    r"""Mimick functionality of tf.math.cumprod(..., exclusive=True), as it isn't available in PyTorch.

  Args:
    tensor (torch.Tensor): Tensor whose cumprod (cumulative product, see `torch.cumprod`) along dim=-1
      is to be computed.
  
  Returns:
    cumprod (torch.Tensor): cumprod of Tensor along dim=-1, mimiciking the functionality of
      tf.math.cumprod(..., exclusive=True) (see `tf.math.cumprod` for details).
  """
    # TESTED
    # Only works for the last dimension (dim=-1)
    dim = -1
    # Compute regular cumprod first (this is equivalent to `tf.math.cumprod(..., exclusive=False)`).
    cumprod = torch.cumprod(tensor, dim)
    # "Roll" the elements along dimension 'dim' by 1 element.
    cumprod = torch.roll(cumprod, 1, dim)
    # Replace the first element by "1" as this is what tf.cumprod(..., exclusive=True) does.
    cumprod[..., 0] = 1.

    return cumprod


"""#### Compute the "bundle" of rays through all pixels of an image."""


def get_ray_bundle(height: int, width: int, focal_length: float, tform_cam2world: torch.Tensor):
    r"""Compute the bundle of rays passing through all pixels of an image (one ray per pixel).

  Args:
    height (int): Height of an image (number of pixels).
    width (int): Width of an image (number of pixels).
    focal_length (float or torch.Tensor): Focal length (number of pixels, i.e., calibrated intrinsics).
    tform_cam2world (torch.Tensor): A 6-DoF rigid-body transform (shape: :math:`(4, 4)`) that
      transforms a 3D point from the camera frame to the "world" frame for the current example.
  
  Returns:
    ray_origins (torch.Tensor): A tensor of shape :math:`(width, height, 3)` denoting the centers of
      each ray. `ray_origins[i][j]` denotes the origin of the ray passing through pixel at
      row index `j` and column index `i`.
      (TODO: double check if explanation of row and col indices convention is right).
    ray_directions (torch.Tensor): A tensor of shape :math:`(width, height, 3)` denoting the
      direction of each ray (a unit vector). `ray_directions[i][j]` denotes the direction of the ray
      passing through the pixel at row index `j` and column index `i`.
      (TODO: double check if explanation of row and col indices convention is right).
  """
    # TESTED
    ii, jj = meshgrid_xy(
        torch.arange(width).to(tform_cam2world),
        torch.arange(height).to(tform_cam2world)
    )
    directions = torch.stack([(ii - width * .5) / focal_length,
                              -(jj - height * .5) / focal_length,
                              -torch.ones_like(ii)
                              ], dim=-1)
    ray_directions = torch.sum(directions[..., None, :] * tform_cam2world[:3, :3], dim=-1)
    ray_origins = tform_cam2world[:3, -1].expand(ray_directions.shape)
    return ray_origins, ray_directions


"""#### Compute "query" 3D points given the "bundle" of rays.

We assume that a _near_ and a _far_ clipping distance are provided that delineate the volume of interest. Each ray is evaluated only within these bounds. We randomly sample points along each ray, while trying to ensure most parts of the ray's trajectory are spanned.
"""


class min_max_ray_Model(torch.nn.Module):
    def __init__(self, num_encoding_functions=0, filter_size=255):
        super(min_max_ray_Model, self).__init__()
        # Input layer (default: 39 -> 128)
        # self.layer1 = torch.nn.Conv2d(6 + 6 * 2 * num_encoding_functions, filter_size, kernel_size=1)
        # self.layer1 = torch.nn.Conv2d(6, filter_size, kernel_size=1)
        self.layer1 = torch.nn.Conv2d(64 * 3, filter_size, kernel_size=1)
        # Layer 2 (default: 128 -> 128)
        self.layer2 = torch.nn.Conv2d(filter_size, filter_size, kernel_size=1)
        self.layer2a = torch.nn.Conv2d(filter_size, filter_size, kernel_size=1)
        self.layer2b = torch.nn.Conv2d(filter_size, filter_size, kernel_size=1)
        self.layer2c = torch.nn.Conv2d(filter_size, filter_size, kernel_size=1)
        # self.layer2d = torch.nn.Conv2d(filter_size, filter_size, kernel_size=1)
        # self.layer2e = torch.nn.Conv2d(filter_size, filter_size, kernel_size=1)
        # self.layer2f = torch.nn.Conv2d(filter_size, filter_size, kernel_size=1)
        # self.layer2g = torch.nn.Conv2d(filter_size, filter_size, kernel_size=1)
        # Layer 3 (default: 128 -> 4)
        self.layer3 = torch.nn.Conv2d(filter_size, 3, kernel_size=1)
        # Short hand for torch.nn.functional.relu
        self.relu = torch.nn.functional.elu

        # self.omega_0 = 1.0
        # for m in self.modules():
        #     if isinstance(m, torch.nn.Conv2d):
        #         torch.nn.init.uniform_(m.weight.data
        #             -np.sqrt(6 / filter_size) / self.omega_0, np.sqrt(6 / filter_size) / self.omega_0)

    def forward(self, x):
        # x = torch.sin(self.omega_0 * self.layer1(x/10))
        # x = torch.sin(self.omega_0 * self.layer2(x))
        # x = torch.sin(self.omega_0 * self.layer2a(x))
        # x = torch.sin(self.omega_0 * self.layer2b(x))
        # x = torch.sin(self.omega_0 * self.layer2c(x))
        # x = torch.sin(self.omega_0 * self.layer2d(x))
        # x = torch.sin(self.omega_0 * self.layer2e(x))

        x = self.relu(self.layer1(x/10))

        x = self.relu(self.layer2(x))
        x = self.relu(self.layer2a(x))
        x = self.relu(self.layer2b(x))
        x = self.relu(self.layer2c(x))
        # x = self.relu(self.layer2d(x))
        # x = self.relu(self.layer2e(x))
        # x = self.relu(self.layer2f(x))
        # x = self.relu(self.layer2g(x))

        x = self.layer3(x)
        return x


"""#### Volumetric rendering

> **NOTE**: This volumetric rendering module (like the authors' tiny_nerf [Colab notebook](https://colab.research.google.com/github/bmild/nerf/blob/master/tiny_nerf.ipynb) does not implement 5D input (which includes view directions, in addition to X, Y, Z coordinates). It also does not implement the hierarchical sampling procedure. For those implementations, refer to the other complete examples in the repo.
"""


"""## Determine device to run on (GPU vs CPU)"""

print(f'using {"cuda" if torch.cuda.is_available() else "cpu"} device')
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

"""## Load up input images, poses, intrinsics, etc."""

# Load input images, poses, and intrinsics
data = np.load("tiny_nerf_data.npz")

# Images
images = data["images"]
# Camera extrinsics (poses)
tform_cam2world = data["poses"]
tform_cam2world = torch.from_numpy(tform_cam2world).to(device)
# Focal length (intrinsics)
focal_length = data["focal"]
focal_length = torch.from_numpy(focal_length).to(device)

# Height and width of each image
height, width = images.shape[1:3]

# Near and far clipping thresholds for depth values.
near_thresh = 1.0
far_thresh = 7.

# Hold one image out (for test).
testimg, testpose = images[101], tform_cam2world[101]
testimg = torch.from_numpy(testimg).to(device)

# Map images to device
images = torch.from_numpy(images[:100, ..., :3]).to(device)

"""#### Display the image used for testing"""

plt.imshow(testimg.detach().cpu().numpy())
plt.savefig('ToyResults/GT.png')

"""## Train TinyNeRF!

(The cool part!)
"""


# One iteration of TinyNeRF (forward pass).
def run_one_iter_of_tinynerf(height, width, focal_length, tform_cam2world,
                             near_thresh, far_thresh):
    # Get the "bundle" of rays through all image pixels.
    ray_origins, ray_directions = get_ray_bundle(height, width, focal_length,
                                                 tform_cam2world)

    # Sample query points along each ray

    mm_input = torch.linspace(near_thresh, far_thresh, 64).to(ray_origins)
    mm_input = ray_origins[..., None, :] + ray_directions[..., None, :] * mm_input[..., :, None]  # W, H, 8, 3
    mm_input = mm_input.view(ray_origins.shape[0], ray_origins.shape[1], 64 * ray_origins.shape[2])
    mm_input = torch.transpose(mm_input.unsqueeze(0), 1, 3)  # (1, 6 + 6 * 2 * num_encoding_functions, height, width)
    rgb_predicted = mm_model(mm_input)
    rgb_predicted = torch.transpose(rgb_predicted.squeeze(0), 0, 2)  # (width, height, 2)

    return rgb_predicted


def log_stuff(rgb_predicted, i, iternums, psnrs=None, train_losses=None):
    plt.figure(figsize=(5*2, 5))
    plt.subplot(121)
    plt.imshow(rgb_predicted.detach().cpu().numpy())
    plt.title(f"Iteration {i}")

    if psnrs is not None:
        plt.subplot(122)
        plt.plot(iternums, psnrs)
        plt.title("Val PSNR")
    elif train_losses is not None:
        plt.subplot(122)
        plt.plot(iternums, train_losses)
        plt.title("Train Loss")

    if psnrs is not None:
        plt.savefig('ToyResults/val_ray.png')
    elif train_losses is not None:
        plt.savefig('ToyResults/train_ray.png')


"""
Parameters for TinyNeRF training
"""

# Number of functions used in the positional encoding (Be sure to update the 
# model if this number changes).
num_encoding_functions = 6
# Number of depth samples along each ray.
depth_samples_per_ray = 4

# Chunksize (Note: this isn't batchsize in the conventional sense. This only
# specifies the number of rays to be queried in one go. Backprop still happens
# only after all rays from the current "bundle" are queried and rendered).
chunksize = 16384  # Use chunksize of about 4096 to fit in ~1.4 GB of GPU memory.

# Optimizer parameters
lr = 1e-3
a_p = 0.001
a_sch = 10000
num_iters = 200000

# Misc parameters
display_every = 2000  # Number of iters after which stats are displayed

"""
Model
"""
mm_model = min_max_ray_Model(num_encoding_functions=num_encoding_functions)
mm_model.to(device)

"""
Optimizer
"""
optimizer = torch.optim.Adam(mm_model.parameters(), lr=lr)

"""
Train-Eval-Repeat!
"""

# Seed RNG, for repeatability
seed = 9458
torch.manual_seed(seed)
np.random.seed(seed)

# Lists to log metrics etc.
psnrs = []
train_losses = []
iternums = []

for i in range(num_iters):

    # Randomly pick an image as the target.
    target_img_idx = np.random.randint(images.shape[0])
    target_img = images[target_img_idx].to(device)
    target_tform_cam2world = tform_cam2world[target_img_idx].to(device)

    # Run one iteration of TinyNeRF and get the rendered RGB image.
    rgb_predicted = run_one_iter_of_tinynerf(height, width, focal_length,
                                             target_tform_cam2world, near_thresh, far_thresh)

    # Compute mean-squared error between the predicted and target images. Backprop!
    loss = torch.nn.functional.mse_loss(rgb_predicted, target_img)
    # loss = torch.mean(torch.abs(rgb_predicted - target_img))
    if a_p > 0 and i >= a_sch:
        # reshape for vgg
        rgb_predicted_ = torch.transpose(rgb_predicted, 0, 2).unsqueeze(0)
        target_img_ = torch.transpose(target_img, 0, 2).unsqueeze(0)
        loss = loss + a_p * perceptual_loss(vgg(rgb_predicted_), vgg(target_img_))
    loss.backward()
    optimizer.step()
    optimizer.zero_grad()

    # Display images/plots/stats
    if i % display_every == 0:
        iternums.append(i)

        # Render training view
        train_losses.append(loss.detach().item())
        log_stuff(rgb_predicted, i, iternums, train_losses=train_losses)

        # Render the held-out view
        rgb_predicted = run_one_iter_of_tinynerf(height, width, focal_length, testpose, near_thresh, far_thresh)
        loss = torch.nn.functional.mse_loss(rgb_predicted, testimg)
        print("Loss:", loss.item())
        psnr = -10. * torch.log10(loss)

        psnrs.append(psnr.item())
        log_stuff(rgb_predicted, i, iternums, psnrs=psnrs)

print('Done!')
